(Japanese, Shift_JIS)

------------------------------------------------------------------------------
IME開発のためのWin32多言語IMEの概要
片山博文MZ
------------------------------------------------------------------------------

=概要

Windows 95とNT 4.0以降では、IME (Input Method Editor) という入力用のソフトが、
DLL形式で提供される。IME、およびシステム側でIMEを管理するIMM
 (Input Method Manager) は、

 * 多言語環境のコンポーネントとして走り、
 * それぞれのアプリのタスクごとに複数のインプットコンテキスト (Input Context)が
   提供され、
 * それぞれのアプリのスレッドごとに一つのアクティブなIMEが保たれ、
 * （メッセージ順を壊すことなく）メッセージループを通じて、アプリに情報を提供し、
 * IMEを意識したアプリかそうでないかに関わらず、強いサポートを提供する。

注記：IME開発者は、<imm.h>のスーパーセットである、DDKの<immdev.h>を使わなければ
      ならない。

=Windows 98 and Windows 2000 IMM/IME

(略)

=Win32 IME構造体

新しいWin32 IMEは、2つのコンポーネントを提供する必要がある。IME変換インターフェイスと
IME操作系 (UI) だ。IME変換インターフェイスは、IMEモジュールからエクスポートされた、
関数群として提供される。それらはIMMによって呼び出せる。IME UIは、ウィンドウ
フォームとして提供される。それらのウィンドウは、メッセージを受け取り、
IMEに対するUIを提供する。

=IMEを意識したアプリ

Win32アプリは三種類に分けられる。

 * IMEを意識していないアプリ
 * IMEを半分意識しているアプリ
 * IMEを完全に意識しているアプリ

IMEを意識していないアプリは、既定のIMEウィンドウと既定の入力コンテキストでサポート
される。

IMEを半分意識しているアプリは、既定のIMEウィンドウクラスを使って、
(アプリIMEウィンドウと呼ばれる) IMEウィンドウを所有しつつ、
独自の入力コンテキストを取り扱うかもしれない。

IMEを完全に意識しているアプリは、それ自身が入力コンテキストを取り扱い、
必要な情報を、IMEウィンドウを使うことなく、表示できる。

=IME UI

IME操作系 (UI) は、IMEウィンドウ、UIウィンドウを含み、さらにUIウィンドウの
コンポーネントも含んでいる。

==特徴

IMEクラスとは、定義済みのグローバルなウィンドウクラスであり、
IMEの操作系をすべて実現する。IMEクラスの通常の特徴は、
他のコントロールと同じである。
そのウィンドウインスタンスは、CreateWindowEx関数で作成できる。
スタティックコントロールのように、ユーザーの入力に反応させなくすることも
できるが、IMEのすべての操作系を実現するために、あらゆる種類の
コントロールメッセージを受け取る。Win32アプリは、IMEクラスを使って
所有するIMEウィンドウを作成できるし、既定のIMEウィンドウを
ImmGetDefaultIMEWnd関数を通じて取得できる。古いWindows 3.1とは
違って、次のような利点がある。

 * 新しいIMEは、候補リストウィンドウを含む。
 * IME UIウィンドウは、アプリのウィンドウハンドルを知らされて、
   アプリにさまざまなふるまいを提供できる。

システムは、一つだけのIMEクラスを提供するが、それらは、
二種類のIMEウィンドウである。一つは、特にIMEを意識していないアプリに
おいて、DefWindowProc関数によって、システムによって作られるものだ。
もう一つは、IMEを意識したアプリにより作成され、アプリIMEウィンドウと
呼ばれるものだ。

=既定の、またはアプリのIMEウィンドウ

システムは、既定のIMEウィンドウをスレッドの初期化時に作成し、
それをスレッドに自動的に渡す。このIMEウィンドウが、IMEを意識していない
アプリのIME操作系となる。

IMEやIMMがWM_IME_xxxメッセージを生成するとき、IMEを意識していないアプリは、
それらをDefWindowProc関数に渡す。それから、必要なメッセージを
DefWindowProcBが既定のIMEウィンドウに送信する。
IMEを意識していないアプリでは、既定のIMEウィンドウはIMEの既定のふるまいを提供する。
IMEを意識しているアプリは、メッセージをフックしていないときでも
IMEウィンドウを使う。アプリは、必要に応じて、アプリ所有のIMEウィンドウを
使うことができる。

==IMEクラス

Win32システムは、IMEクラス（ウィンドウクラス）を提供する。このクラスは、
定義済みのEDITクラスのようなユーザーによって定義される。
システムIMEクラスは、IMEのすべてのUIを取り扱い、IMEと
アプリ（IMM関数を含む）からすべてのコントロールメッセージを取り扱う。
アプリは、このクラスを使って固有のIME UIを作成できる。
システムIMEクラスは、IMEによっては置き換えられないが、
定義済みクラスとして保たれる。

このクラスは、ウィンドウプロシージャを持つ。それは、実際に、
WM_IME_SELECTメッセージを取り扱う。このメッセージは、
新しく選択されたIMEのhKL (キーボードレイアウトのハンドル)を持っている。
システムIMEクラスは、hKLによってそれぞれのIMEで定義されたクラスの名前を
取得する。この名前を使って、システムIMEクラスは、
現在アクティブなIMEのUIウィンドウを作成する。

=IMEからのUIクラス

設計では、すべてのIMEは、システムに対してそれ自身のUIクラスを登録するよう、
想定している。それぞれのIMEによって提供されるUIクラスは、IME特有の
機能に対して責任がある。IMEは、IMEがプロセスにアタッチされるとき、
IME自身がそのIMEで使われるいくつかのクラスを登録する。これは、
DLLのエントリポイントがDLL_PROCESS_ATTACHで呼ばれるときに起こる。
IMEは、そのとき、ImeInquire関数の第二引数としてクラス名をセットしないと
いけない。

UIクラスは、IMEクラスとして使えるよう、CS_IMEスタイルを付けて
登録されるべきだ。(ナル文字を含む) UIクラス名は、16文字までであるが、
将来増えるかもしれない。

UIクラスのcbWndExtraメンバーは、2 * sizeof(LONG)でなければならない。
割り増しのデータは、例えばIMMGWL_IMCとIMMGWL_PRIVATEで使われる。

IMEは、どんなウィンドウクラスも登録でき、アプリで動作するどんなウィンドウ
も作成できる。

(例は略)

=UIウィンドウ

IMEクラスのIMEウィンドウは、アプリかシステムによって作成される。
IMEウィンドウが作成されたら、IMEによって提供されるUIウィンドウが
作成され、IMEウィンドウによって所有される。

それぞれのUIウィンドウは、現在の入力コンテキストを所有する。
この入力コンテキストは、UIウィンドウがWM_IME_xxxメッセージを
受け取ったときに、GetWindowLong関数にIMMGWL_IMCをつけて呼び出すことで
取得できる。UIウィンドウは、この入力コンテキストを参照でき、
メッセージを取り扱うことができる。
GetWindowLong関数にIMMGWL_IMCをつけて入力コンテキストを取得することは、
UIウィンドウプロシージャの間、いつでも可能だ
（ただしWM_CREATEメッセージを除く）。

UIウィンドウのcbWndExtraは、IMEによって拡張できない。IMEが
ウィンドウインスタンスの余分なデータを使う必要がある場合は、
UIウィンドウは、IMMGWL_PRIVATEをつけてSetWindowLongとGetWindowLong関数を
使う。このIMMGWL_PRIVATEは、LONG値の余分なデータを提供する。
UIウィンドウのプライベートなことで、データが必要なら、IMMGWL_PRIVATE
領域にメモリブロックのハンドルを置くことができる。
UIウィンドウプロシージャは、DefWindowProc関数が使えるが、
UIウィンドウは、WM_IME_xxxメッセージをDefWindowProcに渡すことは
できない。このメッセージがUIウィンドウプロシージャによって取り扱わなくても、
UIウィンドウは、DefWindowProcにそれを渡さない。

(例は略)

UIウィンドウは、現在選択中の入力コンテキストを参照することによる、すべてのタスクを
成し遂げなければならない。アプリのウィンドウがアクティブになったとき、
UIウィンドウは、現在の入力コンテキストを含むメッセージを受け取る。
UIウィンドウは、そのとき、入力コンテキストを使う。
よって、入力コンテキストは、UIウィンドウが変換ウィンドウ・状態ウィンドウなどを
表示するためのすべての情報を含んでいないといけない。
UIウィンドウは、入力コンテキストを参照するが、更新する必要はない。
しかしながら、もしUIウィンドウが入力コンテキストを更新したければ、
それは、IMM関数を呼ぶべきだ。なぜなら、入力コンテキストは、IMMによって
管理され、IMMはIMEと一緒に、入力コンテキストが変更されたとき、IMEが
通知すべきだからである。

例えば、UI ウィンドウはときおり、ユーザーがマウスをクリックしたとき、
入力コンテキストの変換モードを変更する必要がある。
このとき、UIウィンドウは、ImmSetConversionMode関数を呼ぶべきである。
ImmSetConversionMode関数は、WM_IME_NOTIFYを持ったUIウィンドウとNotifyIMEへ通知を作成する。
UIウィンドウが変換モードの表示を変更したいなら、UIウィンドウは、
WM_IME_NOTIFYメッセージを待つべきである。

=UIウィンドウのコンポーネント

UIウィンドウは、現在の入力コンテキストを参照することにより、変換ウィンドウや状態ウィンドウを
登録・表示できる。UIウィンドウのコンポーネントのクラススタイルは、CS_IMEビットを含んで
いなければならない。UIウィンドウのウィンドウインスタンスは、
入力コンテキストから変換中の文字列、フォント、そして位置の情報を得る。

アプリのウィンドウがフォーカスを得たとき、システムは、入力コンテキストを
このウィンドウに与え、現在の入力コンテキストをUIウィンドウにセットする。
システムは、そのとき、WM_IME_SETCONTEXTメッセージに入力コンテキストをつけて、
アプリへ送信する。すると、アプリはこのメッセージをUIウィンドウに渡す。
もし、現在の入力コンテキストが他の入力コンテキストに入れ替えていたら、
UIウィンドウは、変換ウィンドウを再描画すべきだ。
いつでも、現在の入力コンテキストは変更され、UIウィンドウは
正しい変換ウィンドウを表示する。
したがって、IMEの状態は保証される。

UIウィンドウは、その状態や変換文字列、候補リストを表示するために、
子ウィンドウやポップアップウィンドウを作成できる。
しかしながら、それらのウィンドウは、UIウィンドウによって所有される必要があり、
また、無効な (disabled) ウィンドウとして作成される必要がある。
IMEによって作成されたどんなウィンドウも、フォーカスを得てはならない。

=IME入力コンテキスト

それぞれのウィンドウは、IME入力コンテキストに関連付けられる。
IMMは、IMEの状態を管理するために、また、IMEとアプリの間で通信するために、
入力コンテキストを使う。

==既定の入力コンテキスト

既定では、システムは各スレッドのために、既定の入力コンテキストを作成する。
すべての、IMEを意識しないウィンドウはこのコンテキストを共有する。

=アプリ作成の入力コンテキスト

アプリのウィンドウは、未決定の変換文字列を含むIMEの状態を管理するために、
ウィンドウハンドルを入力コンテキストに関連付けできる。
一度、アプリが入力コンテキストをウィンドウハンドルに関連付けると、
システムはウィンドウがアクティブになったときに自動的にコンテキストを選択する。
このように、アプリは、フォーカスの取得・解放処理における複雑さから
解放されている。

=入力コンテキストの使用

アプリまたはシステムが新しい入力コンテキストを作成するとき、
システムは、新しい入力コンテキストにIMC (IMCC)のコンポーネント群を用意する。
コンポーネント群は、hCompStr、hCandInfo、hGuideLine、hPrivate、
そしてhMsgBufを含む。基本天気に、IMEは、入力コンテキストとそのコンポーネントを
作成しない。IMEは、それらのコンポーネントのサイズを変更でき、
そのポインタを取得するために、ロックできる。

==HIMCへのアクセス

IMEが入力コンテキストにアクセスするとき、
IMEは、入力コンテキストのポインタを取得するためにImmLockIMC関数を呼ぶ。
ImmLockIMC関数は、IMM のロックカウントを１つ増加させ、
ImmUnlockIMC関数は、IMMのロックカウントを１つ減少させる。

時として、IMEは、入力コンテキストの新しいコンポーネントを作成する必要がある。
そのため、IMEは、ImmCreateIMCC関数を呼ぶことができる。
入力コンテキスト中の新しく作成したコンポーネントを破壊するために、
IMEはImmDestroyIMCC関数を呼ぶことができる。

(例は略)

=メッセージの生成

IMEはIMEメッセージを生成する必要がある。
IMEが変換プロセスを初期化したとき、IMEは、
WM_IME_STARTCOMPOSITIONメッセージを生成する必要がある。
もし、IMEが変換文字列を変更したら、IMEは、WM_IME_COMPOSITIONメッセージを生成する
必要がある。
IMEがメッセージを生成する方法には、二通りある。
一つは、ImeToAsciiEx関数で提供されるlpdwTransKeyバッファを使うこと、
もう一つは、ImmGenerateMessage関数を呼ぶことだ。

==メッセージ生成にlpdwTransKeyを使う方法

IMEによって開始されたイベントは、入力コンテキストに関連付けられたウィンドウへの
メッセージを生成するように実現される。
基本的に、IMEはImeToAsciiExの引数として提供されたlpTransMsgListを使って、
メッセージを生成する。ImeToAsciiExが呼ばれたとき、IMEはlpTransMsgListバッファへ、
メッセージを置く。

ImeToAsciiEx関数の引数lpTransMsgListで指定されたバッファは、
システムによって提供される。
この関数は、一度にバッファ内の全部のメッセージを置くことができる。
メッセージの本当の個数は、バッファ先頭のダブルワード値で与えられる。
しかしながら、もし、ImeToAsciiEx関数が、与えられた個数よりも多くの
メッセージを生成したいなら、ImeToAsciiEx関数は、入力コンテキスト内の
hMsgBufへ、すべてのメッセージを置くことができ、そのときメッセージの個数が
返される。ImeToAsciiExの戻り値がlpTransMsgListで指定された値よりも大きいとき、
システムは、lpTransMsgListからメッセージを取り出さない。
代わりに、システムは入力コンテキスト内のhMsgBufを見る。
このhMsgBufは、ImeToAsciiExの引数として渡される。

(例は略)

==メッセージ生成にメッセージバッファを使う方法

もし、ImeToAsciiEx が呼ばれなかったとしても、IMEは、まだメッセージを、
入力コンテキストに関連付けられたウィンドウに生成することができる。
このメッセージバッファは、メモリーブロックのハンドルとして処理され、
IMEは、メッセージをこのメモリーブロックへ置く。
それからIMEは、ImmGenerateMessage関数を呼び、それが、
適切なウィンドウへのメッセージバッファに格納されたメッセージを送信する。

(例は略)

==WM_IME_COMPOSITION

IMEがWM_IME_COMPOSITION メッセージを生成したとき、
IMEは、lParamをGCSビット群として指定する。
そしてGCSビット群は、COMPOSITIONSTRING構造体の利用可能なメンバーを通知する。
IMEが更新せず、メンバー利用可能でなかったとしても、
IMEは、GCSビット群をセットできる。

IMEがWM_IME_COMPOSITIONメッセージを生成したとき、
IMEはなお、文字列属性と文節情報をすべて一度で変更できる。
the IME can also change the string attribute and
clause information all at once.

=ImeSetCompositionString

ImeSetCompositionString関数は、アプリがIME変換文字列を操作するために使われる。
別のフラグを指定することで、アプリは、変換文字列、属性などを変更できる。
第二引数dwIndexは、IMEにおいてどのように変換文字列を補正するかを指定する。
それは、SCS_SETSTR、SCS_CHANGEATTR、SCS_CHANGECLAUSE、
SCS_QUERYRECONVERTSTRINGなどの値を含む。
それぞれの値が特定の機能を表現する。

==ImeSetCompositionString Capability

IMEがImeSetCompositionStringの能力を持たないとき、
IMEINFO構造体のどんなSCS能力も指定できない。
IMEがImeSetCompositionStringを取り扱うことができるとき、
それはSCS_COMPSTRビットをセットする。
もしIMEが変換文字列から読みの文字列を生成できるなら、
それはSCS_CAP_MAKEREADビットをセットする。
もしIMEがSCS_CAP_COMPSTR能力を持っていれば、
ImeSetCompositionString関数が呼ばれるであろう。
この呼び出しの反応では、IMEは、アプリによって
生成された新しい変換文字列を使い、WM_IME_COMPOSITIONメッセージを
生成するべきだろう。

==SCS_SETSTR

ImeSetCompositionStringのdwIndexがSCS_SETSTRであれば、
IME はhIMCのCOMPOSITIONSTR構造体のすべてを消去できる。

必要なら、IMEは候補情報を更新したり、候補メッセージWM_IME_NOTIFYに
IMN_OPENCANDIDATE、CHANGECANDIDATE、またはIMN_CLOSECANDIDATEサブメッセージを
つけて生成できる。

IMEは、以下のように異なる入力引数に基づくアプリの要件に反応する必要がある。

 * もし、ImeSetCompositonString のlpRead引数が利用可能であれば：
   IMEは、変換文字列を、読みの文字列lpReadから作成できる。
   IMEはそのとき、新しい変換文字列と読み文字列lpReadのために、
   属性と文節を作成する。IMEは、WM_IME_COMPOSITION メッセージを
   GCS_COMPかGCS_COMPREADのいずれかをつけて、生成する。
   ときおり、IMEは、変換を自動的にファイナライズしうる。
   IMEはそのとき、WM_IME_COMPOSITIONメッセージを、GCS_COMPxxxの代わりに
   GCS_RESULTかGCS_RESULTREAD をつけて生成できる。

 * もし、ImeSetCompositonStringの引数lpCompが利用可能であれば：
   IMEは、変換属性と文節情報を変換文字列（lpCompに含まれる）から、
   作成すべきだ。IMEはそのとき、WM_IME_COMPOSITIONメッセージを
   GCS_COMPをつけて生成する。もしIMEがSCS_CAP_MAKEREADの能力が
   あれば、IMEは、新しい読みの文字列も同時に作成すべきだ。
   IMEはそのとき、WM_IME_COMPOSITION メッセージを
   GCS_COMPかGCS_COMPREADのいずれかをつけて生成する。
   ときおり、IMEは、変換をファイナライズしうる。
   IMEはそのとき、WM_IME_COMPOSITIONメッセージを、
   GCS_COMPxxxの代わりにGCS_RESULT かGCS_RESULTREAD のいずれかをつけて
  生成できる。
 * lpRead とlpComp の両方利用可能であれば：
   IMEは、変換文字列と対応する読みの文字列を作成すべきだ。
   この場合、IME は、lpComp とlpRead に完全に従う必要はない。
   もし、IMEが、アプリによって指定されたlpReadとlpCompの
   関係がわからないときは、変換文字列を修正すべきだ。
   IMEはそのとき、新しい変換文字列と読みの文字列lpReadの
   両方に属性と文節情報を作成できる。
   IMEはそのとき、WM_IME_COMPOSITION メッセージを
   GCS_COMPかGCS_COMPREADのいずれかをつけて生成する。
   ときおり、IMEは、変換をファイナライズしうる。
   IMEはそのとき、WM_IME_COMPOSITION メッセージを、
   GCS_COMPxxxの代わりに、GCS_RESULT かGCS_RESULTREAD のいずれかをつけて
   生成できる。

==SCS_CHANGEATTR

SCS_CHANGEATTRは、属性情報にのみ影響する。
IMEは、変換文字列、変換文字列の文節情報、変換文字列の読み、
または、読み文字列の文節情報を更新すべきではない。

IMEは最初に、新しい属性を受け入れ可能かどうかをチェックする必要がある。
そしてそれは、hIMCのCOMPOSITIONSTRING 構造体の中の新しい属性をセットする。
最後に、IME は、WM_IME_COMPOSITION メッセージを生成する。

必要ならば、IMEは、候補情報を更新し、候補メッセージWM_IME_NOTIFYを
サブメッセージIMN_OPENCANDIDATE、CHANGECANDIDATE、または
IMN_CLOSECANDIDATE をつけて、生成できる。

この特徴のために、IMEは、変換文字列をファイナライズできない。
IMEは、以下のような異なる入力引数に基づくアプリの要件に応えないといけない。

 * もしImeSetCompositonStringの引数lpRead が利用可能であれば：
   IMEは、lpRead の新しい属性に従うべきであり、そして現在の変換文字列に対する
   変換文字列の新しい属性を作成するべき。この場合、文節情報は変更しない。
   IMEは、WM_IME_COMPOSITION メッセージをGCS_COMP かGCS_COMPREADのいずれかを
   つけて生成される。もし、lpReadに含まれる新しい属性が受け入れられないならば、
   何もメッセージを生成せず、戻り値としてFALSEを返す。
 * もし、ImeSetCompositonString の引数lpComp が利用可能であれば：
   IMEは、lpCompの新しい属性に従う。この場合、文節情報は変更されない。
   もしIMEの能力がSCS_CAP_MAKEREAD を持っていて、
   読みの文字列が利用可能であれば、IMEは、
   現在の変換文字列の現在の読みの文字列に対する
   新しい変換文字列の読みの属性を作成すべきだ。
 * lpRead とlpComp の両方が利用可能であれば：
   IMEが新しい情報を受け入れることができれば、
   hIMCのCOMPOSITION構造体の新しい情報をセットし、
   WM_IME_COMPOSITION メッセージをGCS_COMP かGCS_COMPREADのいずれかを
   つけて生成する。

==SCS_CHANGECLAUSE

SCS_CHANGECLAUSEは、変換文字列と変換文字列の読みの両方に対する文字列と属性に影響する。

必要であれば、IMEは候補情報を更新でき、候補メッセージWM_IME_NOTIFY を
サブメッセージIMN_OPENCANDIDATE、CHANGECANDIDATE、またはIMN_CLOSECANDIDATEをつけて
生成できる。

IME は、異なる入力引数を基にするアプリの要件に応える必要がある。
以下は、IMEが変換文字列をファイナライズできない例である。

 * もしImeSetCompositonString の引数lpRead が利用可能であれば：
   IMEは、lpRead の新しい読み文節情報に従い、変換文字列の読みの
   属性を修正する必要がある。IMEはそして、変換文字列、変換文字列の属性・
   文節情報を更新できる。IMEは、WM_IME_COMPOSITION メッセージを、
   GCS_COMP かGCS_COMPREADのいずれかをつけて生成する。
 * もしImeSetCompositonString の引数lpComp が利用可能であれば：
   IMEは、新しい文節情報に従い、変換文字列、変換文字列の属性を修正する
   必要がある。そのとき、IMEは、読み属性と読み属性の文節情報を更新できる。
   IMEはWM_IME_COMPOSITION メッセージを、GCS_COMPSTR かGCS_COMPREADを
   つけて生成する。
 * もしlpRead とlpComp の両方が利用可能であれば：
   IMEが新しい情報を受け入れ可能であれば、hIMCのCOMPOSITION構造体の
   新しい情報をセットし、WM_IME_COMPOSITION メッセージを、
   GCS_COMP かGCS_COMPREADをつけて生成する。

=ソフトキーボード

(略)

=再変換

(略)

=IMEメニュー関数

(略)

Windows システムプログラムは、現在のhKL（キーボードレイアウト）が
IMEであれば、タスクバーに二つのアイコンを導入する。
一つのアイコンは、システムタスクバーにある、
現在のキーボードレイアウトを示すシステムMLアイコンである。
もう一方は、フォーカスされたウィンドウのIME状態を表すシステムペンアイコン。
たいてい、IMEは、追加的なアイコンをタスクバーに置く。
このアイコンに対するコンテキストメニューは、完全にIMEに依存している。
IMEアイコンをタスクバーに持つことは、ユーザーにとって
IMEの特別な機能にアクセスする素早い方法だ。
しかしながら、IMEに関連付けられた三つのアイコンが存在し、それらの
追加的なアイコンは、ユーザが欲する以上のものであるかもしれない。

もしシステムがIMEに対してIMEメニューアイテムをシステムペンアイコンに
挿入する方法を提供すれば、IMEは余分なアイコンをタスクバーに追加する
必要はない。

IMEは、IMEメニュー項目を取得するために、IME関数ImeGetImeMenuItems を呼ぶ。

アプリは、IMEの特別なメニュー項目を取得するために、
ImmGetImeMenuItems を使うことができる。
それらの項目は、コンテキストメニューに追加できる。
ImmNotifyを呼び出すことで、選択項目がIMEによって処理できる。

==IMEメニュー通知

アプリがIMEのメニュー項目を取り扱いたいとき、ImmNotifyIME関数を
呼ぶことができる。IMEによって追加されたメニュー項目が選択されたとき、
フォーカスされたスレッドのもとでNotifyIME が呼ばれる。

=IME Help File

(略)

=IMEに対するインディケータ管理

Windows 98とWindows 2000で定義されたメッセージ集合を使えば、
IME は、システムタスクバー上の
システムペンアイコンに対するアイコンとツールチップを変更できる。

==インディケータウィンドウ

IMEは、FindWindow関数をINDICATOR_CLASSと共に使って、
ウィンドウハンドルを取得できる。

(略)

注記：タスクバー管理の内部設計の要求のため、IMEはINDICM_xxxメッセージに
対してPostMessageを使わねばならない。

==メッセージ

IMEは、異なるタスクを行うために、
次のメッセージをインディケータウィンドウに送信できる。

 * INDICM_SETIMEICON
 * INDICM_SETIMETOOLTIPS
 * INDICM_REMOVEDEFAULTMENUITEMS

=Windows NT とWindows 2000 イシュー

以下のトピックスは、本質的に、Windows NT/2000に関連する特別なイシューを
述べる。しかしながら、いくつかはWindows 98にも適用されうる。

==IMEとローカライズされた言語互換性

Windows 2000 は、すべてのローカライズされた言語バージョンにおける
完全に組み込まれたIMEサポートを持つ。すなわち、IMEはWindows 2000の
どんな言語についてもインストールして使うことができる。
IME開発者は、それらのIMEをそれらの環境でテストすべきだ。
この新しい特徴はまた、
そして、正しい文字セットとフォント情報を含むための、
別の言語のOSにおいても正しく見られる、
IMEヘルプの内容を準備させることをIME開発者に要求する。

また、IME開発者は、Windows 2000に対してはUnicode IMEを開発すべきだ。
Unicode IMEは、どんなシステムロケールでもUnicodeアプリで動作するだろう。
UnicodeではないIMEについては、それらを使うために、
IMEがサポートする言語と同じ言語をサポートするため、
ユーザーはシステムロケールを変更しなければならない。

==Unicodeインターフェイス

Windows 95でサポートされた IMM/IMEインターフェイスのANSI版と共に、
Windows 98はIMEに対してUnicode インターフェイスをサポートする。
Unicode インターフェイスによってシステムと通信するため、

IMEは、IMEINFO 構造体のfdwProperty メンバーの
IME_PROP_UNICODE ビットをセットするべきだ。
fdwProperty は、ImeInquire 関数の最初の引数である。
ImeInquire は、アプリプロセスのすべてのスレッドに対して
IMEを初期化するために呼び出される。
IMEは、単一のシステムにおいて同じIMEINFO 構造体を戻り値として
返すことを想定している。Windows 98は、
ImmIsUIMessageを除くすべてのUnicode関数をサポートする。

=セキュリティ関連

Windows NTに対して、二つの主なセキュリティの関心事がある。
一つは、名前付きオブジェクトで、もう一つはWinlogonである。

==名前付きオブジェクト

IME は、ローカルシステムにおいて、
複数のプロセスからアクセスされる様々な名前付きオブジェクトを
作成したいかもしれない。そのようなオブジェクトは、
ファイル、ミューテックス、イベントを含むかもしれない。
プロセスは、対話的にログオンしている別のユーザーに属するので、
（セキュリティ属性へのポインタとしてNULLを指定して、IMEがオブジェクトを作成した
時にシステムによって作成された）既定のセキュリティ属性は、
すべてのプロセスにとって適切ではないかもしれない。

Windows NTでは、IMEの最初のクライアントプロセスは、
Winlogonプロセスかもしれない。Winlogonプロセスとは、
ユーザーがシステムにログオンさせるプロセスである。
Winlogonプロセスは、ログオンセッションの間、
システムアカウントに属するのだが、それがシステムがシャットダウン
するまで生きていて、既定のセキュリティ属性でIMEによって作成された
名前付きオブジェクトは、ログオンセッションの間、
他のログオンしたユーザーに属する他のプロセスを通じては
アクセスできない。

名前付きオブジェクトに対して適切に設定されたセキュリティ属性を
作成するサンプルIMEソースコードは、Microsoft Platform DDKで提供
されている。サンプルコードを使えば、IMEを書く人は、
ローカルシステム上のIMEのすべてのクライアントプロセスからアクセスされる、
様々な名前付きオブジェクトを作成できる。
サンプルコードによって割り当てられるセキュリティ属性は、プロセスごとである。
IMEは、取り付け時にセキュリティ属性を初期化、または
取り外し時にセキュリティ属性を解放するために、
名前付きオブジェクトをしばしば作成したいかもしれない。
名前付きオブジェクトを作成しないIMEは、しばしば、
名前付きオブジェクトの作成の直前に、
セキュリティ属性を初期化したいかもしれないし、
オブジェクトが作成された直後にセキュリティ属性を
解放したいかもしれない。

==Winlogon

ログオンセッションのユーザーは、まだシステムへのアクセス権が許されないので、
IMEの設定ダイアログで提供された情報は、セキュリティ問題を生じかねない。
だが、システム管理者は、ログオンセッション上でIMEがアクティブに
ならないようにシステムの設定を変更できる。
うまくふるまうIMEは、IMEのクライアントプロセスがWinlogonプロセスだったなら、
ユーザーに設定ダイアログを開くことを許すべきではない。
IMEは、もし、ログオンセッションを実行しているクライアントプロセスが
Winlogonプロセスかどうかを、ImeInquire関数の
引数dwSystemInfoFlags のIME_SYSTEMINFO_WINLOGON ビットにより、
チェックできる。

=IMEファイル形式とデータ構造

