(Japanese, Shift_JIS)

------------------------------------------------------------------------------
IME開発のためのWin32多言語IMEの概要
片山博文MZ
------------------------------------------------------------------------------

=概要

Windows 95とNT 4.0以降では、IME (Input Method Editor) という入力用のソフトが、
DLL形式で提供される。IME、およびシステム側でIMEを管理するIMM
 (Input Method Manager) は、

 * 多言語環境のコンポーネントとして走り、
 * それぞれのアプリのタスクごとに複数のインプットコンテキスト (Input Context)が
   提供され、
 * それぞれのアプリのスレッドごとに一つのアクティブなIMEが保たれ、
 * （メッセージ順を壊すことなく）メッセージループを通じて、アプリに情報を提供し、
 * IMEを意識したアプリかそうでないかに関わらず、強いサポートを提供する。

注記：IME開発者は、<imm.h>のスーパーセットである、DDKの<immdev.h>を使わなければ
      ならない。

=Windows 98 and Windows 2000 IMM/IME

(略)

=Win32 IME構造体

新しいWin32 IMEは、2つのコンポーネントを提供する必要がある。IME変換インターフェイスと
IME操作系 (UI) だ。IME変換インターフェイスは、IMEモジュールからエクスポートされた、
関数群として提供される。それらはIMMによって呼び出せる。IME UIは、ウィンドウ
フォームとして提供される。それらのウィンドウは、メッセージを受け取り、
IMEに対するUIを提供する。

=IMEを意識したアプリ

Win32アプリは三種類に分けられる。

 * IMEを意識していないアプリ
 * IMEを半分意識しているアプリ
 * IMEを完全に意識しているアプリ

IMEを意識していないアプリは、既定のIMEウィンドウと既定の入力コンテキストでサポート
される。

IMEを半分意識しているアプリは、既定のIMEウィンドウクラスを使って、
(アプリIMEウィンドウと呼ばれる) IMEウィンドウを所有しつつ、
独自の入力コンテキストを取り扱うかもしれない。

IMEを完全に意識しているアプリは、それ自身が入力コンテキストを取り扱い、
必要な情報を、IMEウィンドウを使うことなく、表示できる。

=IME UI

IME操作系 (UI) は、IMEウィンドウ、UIウィンドウを含み、さらにUIウィンドウの
コンポーネントも含んでいる。

==特徴

IMEクラスとは、定義済みのグローバルなウィンドウクラスであり、
IMEの操作系をすべて実現する。IMEクラスの通常の特徴は、
他のコントロールと同じである。
そのウィンドウインスタンスは、CreateWindowEx関数で作成できる。
スタティックコントロールのように、ユーザーの入力に反応させなくすることも
できるが、IMEのすべての操作系を実現するために、あらゆる種類の
コントロールメッセージを受け取る。Win32アプリは、IMEクラスを使って
所有するIMEウィンドウを作成できるし、既定のIMEウィンドウを
ImmGetDefaultIMEWnd関数を通じて取得できる。古いWindows 3.1とは
違って、次のような利点がある。

 * 新しいIMEは、候補リストウィンドウを含む。
 * IME UIウィンドウは、アプリのウィンドウハンドルを知らされて、
   アプリにさまざまなふるまいを提供できる。

システムは、一つだけのIMEクラスを提供するが、それらは、
二種類のIMEウィンドウである。一つは、特にIMEを意識していないアプリに
おいて、DefWindowProc関数によって、システムによって作られるものだ。
もう一つは、IMEを意識したアプリにより作成され、アプリIMEウィンドウと
呼ばれるものだ。

=既定の、またはアプリのIMEウィンドウ

システムは、既定のIMEウィンドウをスレッドの初期化時に作成し、
それをスレッドに自動的に渡す。このIMEウィンドウが、IMEを意識していない
アプリのIME操作系となる。

IMEやIMMがWM_IME_xxxメッセージを生成するとき、IMEを意識していないアプリは、
それらをDefWindowProc関数に渡す。それから、必要なメッセージを
DefWindowProcBが既定のIMEウィンドウに送信する。
IMEを意識していないアプリでは、既定のIMEウィンドウはIMEの既定のふるまいを提供する。
IMEを意識しているアプリは、メッセージをフックしていないときでも
IMEウィンドウを使う。アプリは、必要に応じて、アプリ所有のIMEウィンドウを
使うことができる。

==IMEクラス

Win32システムは、IMEクラス（ウィンドウクラス）を提供する。このクラスは、
定義済みのEDITクラスのようなユーザーによって定義される。
システムIMEクラスは、IMEのすべてのUIを取り扱い、IMEと
アプリ（IMM関数を含む）からすべてのコントロールメッセージを取り扱う。
アプリは、このクラスを使って固有のIME UIを作成できる。
システムIMEクラスは、IMEによっては置き換えられないが、
定義済みクラスとして保たれる。

このクラスは、ウィンドウプロシージャを持つ。それは、実際に、
WM_IME_SELECTメッセージを取り扱う。このメッセージは、
新しく選択されたIMEのhKL (キーボードレイアウトのハンドル)を持っている。
システムIMEクラスは、hKLによってそれぞれのIMEで定義されたクラスの名前を
取得する。この名前を使って、システムIMEクラスは、
現在アクティブなIMEのUIウィンドウを作成する。

=IMEからのUIクラス

設計では、すべてのIMEは、システムに対してそれ自身のUIクラスを登録するよう、
期待している。それぞれのIMEによって提供されるUIクラスは、IME特有の
機能に対して責任がある。IMEは、IMEがプロセスにアタッチされるとき、
IME自身がそのIMEで使われるいくつかのクラスを登録する。これは、
DLLのエントリポイントがDLL_PROCESS_ATTACHで呼ばれるときに起こる。
IMEは、そのとき、ImeInquire関数の第二引数としてクラス名を設定しないと
いけない。

UIクラスは、IMEクラスとして使えるよう、CS_IMEスタイルを付けて
登録されるべきだ。(ナル文字を含む) UIクラス名は、16文字までであるが、
将来増えるかもしれない。

UIクラスのcbWndExtraメンバーは、2 * sizeof(LONG)でなければならない。
割り増しのデータは、例えばIMMGWL_IMCとIMMGWL_PRIVATEで使われる。

IMEは、どんなウィンドウクラスも登録でき、アプリで動作するどんなウィンドウ
も作成できる。

(例は略)

=UIウィンドウ

IMEクラスのIMEウィンドウは、アプリかシステムによって作成される。
IMEウィンドウが作成されたら、IMEによって提供されるUIウィンドウが
作成され、IMEウィンドウによって所有される。

それぞれのUIウィンドウは、現在の入力コンテキストを所有する。
この入力コンテキストは、UIウィンドウがWM_IME_xxxメッセージを
受け取ったときに、GetWindowLong関数にIMMGWL_IMCをつけて呼び出すことで
取得できる。UIウィンドウは、この入力コンテキストを参照でき、
メッセージを取り扱うことができる。
GetWindowLong関数にIMMGWL_IMCをつけて入力コンテキストを取得することは、
UIウィンドウプロシージャの間、いつでも可能だ
（ただしWM_CREATEメッセージを除く）。

UIウィンドウのcbWndExtraは、IMEによって拡張できない。IMEが
ウィンドウインスタンスの余分なデータを使う必要がある場合は、
UIウィンドウは、IMMGWL_PRIVATEをつけてSetWindowLongとGetWindowLong関数を
使う。このIMMGWL_PRIVATEは、LONG値の余分なデータを提供する。
UIウィンドウのプライベートなことで、データが必要なら、IMMGWL_PRIVATE
領域にメモリブロックのハンドルを置くことができる。
UIウィンドウプロシージャは、DefWindowProc関数が使えるが、
UIウィンドウは、WM_IME_xxxメッセージをDefWindowProcに渡すことは
できない。このメッセージがUIウィンドウプロシージャによって取り扱わなくても、
UIウィンドウは、DefWindowProcにそれを渡さない。

(例は略)

UIウィンドウは、現在選択中の入力コンテキストを参照することによる、すべてのタスクを
成し遂げなければならない。アプリのウィンドウがアクティブになったとき、
UIウィンドウは、現在の入力コンテキストを含むメッセージを受け取る。
UIウィンドウは、そのとき、入力コンテキストを使う。
よって、入力コンテキストは、UIウィンドウが変換ウィンドウ・状態ウィンドウなどを
表示するためのすべての情報を含んでいないといけない。
UIウィンドウは、入力コンテキストを参照するが、更新する必要はない。
しかしながら、もしUIウィンドウが入力コンテキストを更新したければ、
それは、IMM関数を呼ぶべきだ。なぜなら、入力コンテキストは、IMMによって
管理され、IMMはIMEと一緒に、入力コンテキストが変更されたとき、IMEが
通知すべきだからである。

例えば、UI ウィンドウはときおり、ユーザーがマウスをクリックしたとき、
入力コンテキストの変換モードを変更する必要がある。
このとき、UIウィンドウは、ImmSetConversionMode関数を呼ぶべきである。
ImmSetConversionMode関数は、WM_IME_NOTIFYを持ったUIウィンドウとNotifyIMEへ通知を作成する。
UIウィンドウが変換モードの表示を変更したいなら、UIウィンドウは、
WM_IME_NOTIFYメッセージを待つべきである。

=UIウィンドウのコンポーネント

UIウィンドウは、現在の入力コンテキストを参照することにより、変換ウィンドウや状態ウィンドウを
登録・表示できる。UIウィンドウのコンポーネントのクラススタイルは、CS_IMEビットを含んで
いなければならない。UIウィンドウのウィンドウインスタンスは、
入力コンテキストから変換中の文字列、フォント、そして位置の情報を得る。

アプリのウィンドウがフォーカスを得たとき、システムは、入力コンテキストを
このウィンドウに与え、現在の入力コンテキストをUIウィンドウに設定する。
システムは、そのとき、WM_IME_SETCONTEXTメッセージに入力コンテキストをつけて、
アプリへ送信する。すると、アプリはこのメッセージをUIウィンドウに渡す。
もし、現在の入力コンテキストが他の入力コンテキストに入れ替えていたら、
UIウィンドウは、変換ウィンドウを再描画すべきだ。
いつでも、現在の入力コンテキストは変更され、UIウィンドウは
正しい変換ウィンドウを表示する。
したがって、IMEの状態は保証される。

UIウィンドウは、その状態や変換文字列、候補リストを表示するために、
子ウィンドウやポップアップウィンドウを作成できる。
しかしながら、それらのウィンドウは、UIウィンドウによって所有される必要があり、
また、無効な (disabled) ウィンドウとして作成される必要がある。
IMEによって作成されたどんなウィンドウも、フォーカスを得てはならない。

=IME入力コンテキスト

それぞれのウィンドウは、IME入力コンテキストに関連付けられる。
IMMは、IMEの状態を管理するために、また、IMEとアプリの間で通信するために、
入力コンテキストを使う。

==既定の入力コンテキスト

既定では、システムは各スレッドのために、既定の入力コンテキストを作成する。
すべての、IMEを意識しないウィンドウはこのコンテキストを共有する。

=アプリ作成の入力コンテキスト

アプリのウィンドウは、未決定の変換文字列を含むIMEの状態を管理するために、
ウィンドウハンドルを入力コンテキストに関連付けできる。
一度、アプリが入力コンテキストをウィンドウハンドルに関連付けると、
システムはウィンドウがアクティブになったときに自動的にコンテキストを選択する。
このように、アプリは、フォーカスの取得・解放処理における複雑さから
解放されている。

=入力コンテキストの使用

アプリまたはシステムが新しい入力コンテキストを作成するとき、
システムは、新しい入力コンテキストにIMC (IMCC)のコンポーネント群を用意する。
コンポーネント群は、hCompStr、hCandInfo、hGuideLine、hPrivate、
そしてhMsgBufを含む。基本天気に、IMEは、入力コンテキストとそのコンポーネントを
作成しない。IMEは、それらのコンポーネントのサイズを変更でき、
そのポインタを取得するために、ロックできる。

==HIMCへのアクセス

IMEが入力コンテキストにアクセスするとき、
IMEは、入力コンテキストのポインタを取得するためにImmLockIMC関数を呼ぶ。
ImmLockIMC関数は、IMM のロックカウントを１つ増加させ、
ImmUnlockIMC関数は、IMMのロックカウントを１つ減少させる。

時として、IMEは、入力コンテキストの新しいコンポーネントを作成する必要がある。
そのため、IMEは、ImmCreateIMCC関数を呼ぶことができる。
入力コンテキスト中の新しく作成したコンポーネントを破壊するために、
IMEはImmDestroyIMCC関数を呼ぶことができる。

(例は略)

=メッセージの生成
