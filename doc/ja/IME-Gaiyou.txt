(Japanese, Shift_JIS)

------------------------------------------------------------------------------
IME開発のためのWin32多言語IMEの概要
片山博文MZ
------------------------------------------------------------------------------

=概要

Windows 95とNT 4.0以降では、IME (Input Method Editor) という入力用のソフトが、
DLL形式で提供される。IME、およびシステム側でIMEを管理するIMM
 (Input Method Manager) は、

 * 多言語環境のコンポーネントとして走り、
 * それぞれのアプリのタスクごとに複数のインプットコンテキスト (Input Context)が
   提供され、
 * それぞれのアプリのスレッドごとに一つのアクティブなIMEが保たれ、
 * （メッセージ順を壊すことなく）メッセージループを通じて、アプリに情報を提供し、
 * IMEを意識したアプリかそうでないかに関わらず、強いサポートを提供する。

注記：IME開発者は、<imm.h>のスーパーセットである、DDKの<immdev.h>を使わなければ
      ならない。

=Windows 98 and Windows 2000 IMM/IME

(略)

=Win32 IME構造体

新しいWin32 IMEは、2つのコンポーネントを提供する必要がある。IME変換インターフェイスと
IME操作系 (UI) だ。IME変換インターフェイスは、IMEモジュールからエクスポートされた、
関数群として提供される。それらはIMMによって呼び出せる。IME UIは、ウィンドウ
フォームとして提供される。それらのウィンドウは、メッセージを受け取り、
IMEに対するUIを提供する。

=IMEを意識したアプリ

Win32アプリは三種類に分けられる。

 * IMEを意識していないアプリ
 * IMEを半分意識しているアプリ
 * IMEを完全に意識しているアプリ

IMEを意識していないアプリは、既定のIMEウィンドウと既定の入力コンテキストでサポート
される。

IMEを半分意識しているアプリは、既定のIMEウィンドウクラスを使って、
(アプリIMEウィンドウと呼ばれる) IMEウィンドウを所有しつつ、
独自の入力コンテキストを取り扱うかもしれない。

IMEを完全に意識しているアプリは、それ自身が入力コンテキストを取り扱い、
必要な情報を、IMEウィンドウを使うことなく、表示できる。

=IME UI

IME操作系 (UI) は、IMEウィンドウ、UIウィンドウを含み、さらにUIウィンドウの
コンポーネントも含んでいる。

==特徴

IMEクラスとは、定義済みのグローバルなウィンドウクラスであり、
IMEの操作系をすべて実現する。IMEクラスの通常の特徴は、
他のコントロールと同じである。
そのウィンドウインスタンスは、CreateWindowEx関数で作成できる。
スタティックコントロールのように、ユーザーの入力に反応させなくすることも
できるが、IMEのすべての操作系を実現するために、あらゆる種類の
コントロールメッセージを受け取る。Win32アプリは、IMEクラスを使って
所有するIMEウィンドウを作成できるし、既定のIMEウィンドウを
ImmGetDefaultIMEWnd関数を通じて取得できる。古いWindows 3.1とは
違って、次のような利点がある。

 * 新しいIMEは、候補リストウィンドウを含む。
 * IME UIウィンドウは、アプリのウィンドウハンドルを知らされて、
   アプリにさまざまなふるまいを提供できる。

システムは、一つだけのIMEクラスを提供するが、それらは、
二種類のIMEウィンドウである。一つは、特にIMEを意識していないアプリに
おいて、DefWindowProc関数によって、システムによって作られるものだ。
もう一つは、IMEを意識したアプリにより作成され、アプリIMEウィンドウと
呼ばれるものだ。

=既定の、またはアプリのIMEウィンドウ

システムは、既定のIMEウィンドウをスレッドの初期化時に作成し、
それをスレッドに自動的に渡す。このIMEウィンドウが、IMEを意識していない
アプリのIME操作系となる。

IMEやIMMがWM_IME_xxxメッセージを生成するとき、IMEを意識していないアプリは、
それらをDefWindowProc関数に渡す。それから、必要なメッセージを
DefWindowProcBが既定のIMEウィンドウに送信する。
IMEを意識していないアプリでは、既定のIMEウィンドウはIMEの既定のふるまいを提供する。
IMEを意識しているアプリは、メッセージをフックしていないときでも
IMEウィンドウを使う。アプリは、必要に応じて、アプリ所有のIMEウィンドウを
使うことができる。

==IMEクラス

Win32システムは、IMEクラス（ウィンドウクラス）を提供する。このクラスは、
定義済みのEDITクラスのようなユーザーによって定義される。
システムIMEクラスは、IMEのすべてのUIを取り扱い、IMEと
アプリ（IMM関数を含む）からすべてのコントロールメッセージを取り扱う。
アプリは、このクラスを使って固有のIME UIを作成できる。
システムIMEクラスは、IMEによっては置き換えられないが、
定義済みクラスとして保たれる。

このクラスは、ウィンドウプロシージャを持つ。それは、実際に、
WM_IME_SELECTメッセージを取り扱う。このメッセージは、
新しく選択されたIMEのhKL (キーボードレイアウトのハンドル)を持っている。
システムIMEクラスは、hKLによってそれぞれのIMEで定義されたクラスの名前を
取得する。この名前を使って、システムIMEクラスは、
現在アクティブなIMEのUIウィンドウを作成する。

=IMEからのUIクラス

設計では、すべてのIMEは、システムに対してそれ自身のUIクラスを登録するよう、
期待している。それぞれのIMEによって提供されるUIクラスは、IME特有の
機能に対して責任がある。IMEは、IMEがプロセスにアタッチされるとき、
IME自身がそのIMEで使われるいくつかのクラスを登録する。これは、
DLLのエントリポイントがDLL_PROCESS_ATTACHで呼ばれるときに起こる。
IMEは、そのとき、ImeInquire関数の第二引数としてクラス名を設定しないと
いけない。

UIクラスは、IMEクラスとして使えるよう、CS_IMEスタイルを付けて
登録されるべきだ。(ナル文字を含む) UIクラス名は、16文字までであるが、
将来増えるかもしれない。

UIクラスのcbWndExtraメンバーは、2 * sizeof(LONG)でなければならない。
割り増しのデータは、例えばIMMGWL_IMCとIMMGWL_PRIVATEで使われる。

IMEは、どんなウィンドウクラスも登録でき、アプリで動作するどんなウィンドウ
も作成できる。

(例は略)

=UIウィンドウ

IMEクラスのIMEウィンドウは、アプリかシステムによって作成される。
IMEウィンドウが作成されたら、IMEによって提供されるUIウィンドウが
作成され、IMEウィンドウによって所有される。

それぞれのUIウィンドウは、現在の入力コンテキストを所有する。
この入力コンテキストは、UIウィンドウがWM_IME_xxxメッセージを
受け取ったときに、GetWindowLong関数にIMMGWL_IMCをつけて呼び出すことで
取得できる。UIウィンドウは、この入力コンテキストを参照でき、
メッセージを取り扱うことができる。
GetWindowLong関数にIMMGWL_IMCをつけて入力コンテキストを取得することは、
UIウィンドウプロシージャの間、いつでも可能だ
（ただしWM_CREATEメッセージを除く）。

UIウィンドウのcbWndExtraは、IMEによって拡張できない。IMEが
ウィンドウインスタンスの余分なデータを使う必要がある場合は、
UIウィンドウは、IMMGWL_PRIVATEをつけてSetWindowLongとGetWindowLong関数を
使う。このIMMGWL_PRIVATEは、LONG値の余分なデータを提供する。
UIウィンドウのプライベートなことで、データが必要なら、IMMGWL_PRIVATE
領域にメモリブロックのハンドルを置くことができる。
UIウィンドウプロシージャは、DefWindowProc関数が使えるが、
UIウィンドウは、WM_IME_xxxメッセージをDefWindowProcに渡すことは
できない。このメッセージがUIウィンドウプロシージャによって取り扱わなくても、
UIウィンドウは、DefWindowProcにそれを渡さない。

(例は略)

UIウィンドウは、現在選択中の入力コンテキストを参照することによる、すべてのタスクを
成し遂げなければならない。アプリのウィンドウがアクティブになったとき、
UIウィンドウは、現在の入力コンテキストを含むメッセージを受け取る。
UIウィンドウは、そのとき、入力コンテキストを使う。
よって、入力コンテキストは、UIウィンドウが変換ウィンドウ・状態ウィンドウなどを
表示するためのすべての情報を含んでいないといけない。
UIウィンドウは、入力コンテキストを参照するが、更新する必要はない。
しかしながら、もしUIウィンドウが入力コンテキストを更新したければ、
それは、IMM関数を呼ぶべきだ。なぜなら、入力コンテキストは、IMMによって
管理され、IMMはIMEと一緒に、入力コンテキストが変更されたとき、IMEが
通知すべきだからである。

例えば、UI ウィンドウはときおり、ユーザーがマウスをクリックしたとき、
入力コンテキストの変換モードを変更する必要がある。
このとき、UIウィンドウは、ImmSetConversionMode関数を呼ぶべきである。
ImmSetConversionMode関数は、WM_IME_NOTIFYを持ったUIウィンドウとNotifyIMEへ通知を作成する。
UIウィンドウが変換モードの表示を変更したいなら、UIウィンドウは、
WM_IME_NOTIFYメッセージを待つべきである。

=UIウィンドウのコンポーネント

UIウィンドウは、現在の入力コンテキストを参照することにより、変換ウィンドウや状態ウィンドウを
登録・表示できる。UIウィンドウのコンポーネントのクラススタイルは、CS_IMEビットを含んで
いなければならない。UIウィンドウのウィンドウインスタンスは、
入力コンテキストから変換中の文字列、フォント、そして位置の情報を得る。

アプリのウィンドウがフォーカスを得たとき、システムは、入力コンテキストを
このウィンドウに与え、現在の入力コンテキストをUIウィンドウに設定する。
システムは、そのとき、WM_IME_SETCONTEXTメッセージに入力コンテキストをつけて、
アプリへ送信する。すると、アプリはこのメッセージをUIウィンドウに渡す。
もし、現在の入力コンテキストが他の入力コンテキストに入れ替えていたら、
UIウィンドウは、変換ウィンドウを再描画すべきだ。
いつでも、現在の入力コンテキストは変更され、UIウィンドウは
正しい変換ウィンドウを表示する。
したがって、IMEの状態は保証される。

UIウィンドウは、その状態や変換文字列、候補リストを表示するために、
子ウィンドウやポップアップウィンドウを作成できる。
しかしながら、それらのウィンドウは、UIウィンドウによって所有される必要があり、
また、無効な (disabled) ウィンドウとして作成される必要がある。
IMEによって作成されたどんなウィンドウも、フォーカスを得てはならない。

=IME入力コンテキスト

それぞれのウィンドウは、IME入力コンテキストに関連付けられる。
IMMは、IMEの状態を管理するために、また、IMEとアプリの間で通信するために、
入力コンテキストを使う。

==既定の入力コンテキスト

既定では、システムは各スレッドのために、既定の入力コンテキストを作成する。
すべての、IMEを意識しないウィンドウはこのコンテキストを共有する。

=アプリ作成の入力コンテキスト

アプリのウィンドウは、未決定の変換文字列を含むIMEの状態を管理するために、
ウィンドウハンドルを入力コンテキストに関連付けできる。
一度、アプリが入力コンテキストをウィンドウハンドルに関連付けると、
システムはウィンドウがアクティブになったときに自動的にコンテキストを選択する。
このように、アプリは、フォーカスの取得・解放処理における複雑さから
解放されている。

=入力コンテキストの使用

アプリまたはシステムが新しい入力コンテキストを作成するとき、
システムは、新しい入力コンテキストにIMC (IMCC)のコンポーネント群を用意する。
コンポーネント群は、hCompStr、hCandInfo、hGuideLine、hPrivate、
そしてhMsgBufを含む。基本天気に、IMEは、入力コンテキストとそのコンポーネントを
作成しない。IMEは、それらのコンポーネントのサイズを変更でき、
そのポインタを取得するために、ロックできる。

==HIMCへのアクセス

IMEが入力コンテキストにアクセスするとき、
IMEは、入力コンテキストのポインタを取得するためにImmLockIMC関数を呼ぶ。
ImmLockIMC関数は、IMM のロックカウントを１つ増加させ、
ImmUnlockIMC関数は、IMMのロックカウントを１つ減少させる。

時として、IMEは、入力コンテキストの新しいコンポーネントを作成する必要がある。
そのため、IMEは、ImmCreateIMCC関数を呼ぶことができる。
入力コンテキスト中の新しく作成したコンポーネントを破壊するために、
IMEはImmDestroyIMCC関数を呼ぶことができる。

(例は略)

=メッセージの生成

IMEはIMEメッセージを生成する必要がある。
IMEが変換プロセスを初期化したとき、IMEは、
WM_IME_STARTCOMPOSITIONメッセージを生成する必要がある。
もし、IMEが変換文字列を変更したら、IMEは、WM_IME_COMPOSITIONメッセージを生成する
必要がある。
IMEがメッセージを生成する方法には、二通りある。
一つは、ImeToAsciiEx関数で提供されるlpdwTransKeyバッファを使うこと、
もう一つは、ImmGenerateMessage関数を呼ぶことだ。

==メッセージ生成にlpdwTransKeyを使う方法

IMEによって開始されたイベントは、入力コンテキストに関連付けられたウィンドウへの
メッセージを生成するように実現される。
基本的に、IMEはImeToAsciiExの引数として提供されたlpTransMsgListを使って、
メッセージを生成する。ImeToAsciiExが呼ばれたとき、IMEはlpTransMsgListバッファへ、
メッセージを置く。

ImeToAsciiEx関数の引数lpTransMsgListで指定されたバッファは、
システムによって提供される。
この関数は、一度にバッファ内の全部のメッセージを置くことができる。
メッセージの本当の個数は、バッファ先頭のダブルワード値で与えられる。
しかしながら、もし、ImeToAsciiEx関数が、与えられた個数よりも多くの
メッセージを生成したいなら、ImeToAsciiEx関数は、入力コンテキスト内の
hMsgBufへ、すべてのメッセージを置くことができ、そのときメッセージの個数が
返される。ImeToAsciiExの戻り値がlpTransMsgListで指定された値よりも大きいとき、
システムは、lpTransMsgListからメッセージを取り出さない。
代わりに、システムは入力コンテキスト内のhMsgBufを見る。
このhMsgBufは、ImeToAsciiExの引数として渡される。

(例は略)

==メッセージ生成にメッセージバッファを使う方法

もし、ImeToAsciiEx が呼ばれなかったとしても、IMEは、まだメッセージを、
入力コンテキストに関連付けられたウィンドウに生成することができる。
このメッセージバッファは、メモリーブロックのハンドルとして処理され、
IMEは、メッセージをこのメモリーブロックへ置く。
それからIMEは、ImmGenerateMessage関数を呼び、それが、
適切なウィンドウへのメッセージバッファに格納されたメッセージを送信する。

(例は略)

==WM_IME_COMPOSITION

IMEがWM_IME_COMPOSITION メッセージを生成したとき、
IMEは、lParamをGCSビット群として指定する。
そしてGCSビット群は、COMPOSITIONSTRING構造体の利用可能なメンバーを通知する。
IMEが更新せず、メンバー利用可能でなかったとしても、
IMEは、GCSビット群を設定できる。

IMEがWM_IME_COMPOSITIONメッセージを生成したとき、
IMEはなお、文字列属性と文節情報をすべて一度で変更できる。
the IME can also change the string attribute and
clause information all at once.

=ImeSetCompositionString

ImeSetCompositionString関数は、アプリがIME変換文字列を操作するために使われる。
別のフラグを指定することで、アプリは、変換文字列、属性などを変更できる。
第二引数dwIndexは、IMEにおいてどのように変換文字列を補正するかを指定する。
それは、SCS_SETSTR、SCS_CHANGEATTR、SCS_CHANGECLAUSE、
SCS_QUERYRECONVERTSTRINGなどの値を含む。
それぞれの値が特定の機能を表現する。

==ImeSetCompositionString Capability

IMEがImeSetCompositionStringの能力を持たないとき、
IMEINFO構造体のどんなSCS能力も指定できない。
IMEがImeSetCompositionStringを取り扱うことができるとき、
それはSCS_COMPSTRビットをセットする。
もしIMEが変換文字列から読みの文字列を生成できるなら、
それはSCS_CAP_MAKEREADビットをセットする。
もしIMEがSCS_CAP_COMPSTR能力を持っていれば、
ImeSetCompositionString関数が呼ばれるであろう。
この呼び出しの反応では、IMEは、アプリによって
生成された新しい変換文字列を使い、WM_IME_COMPOSITIONメッセージを
生成するべきだろう。

==SCS_SETSTR

ImeSetCompositionStringのdwIndexがSCS_SETSTRであれば、
IME はhIMCのCOMPOSITIONSTR構造体のすべてを消去できる。

必要なら、IMEは候補情報を更新したり、候補メッセージWM_IME_NOTIFYに
IMN_OPENCANDIDATE、CHANGECANDIDATE、またはIMN_CLOSECANDIDATEサブメッセージを
つけて生成できる。

IMEは、以下のように異なる入力引数に基づくアプリの要件に反応する必要がある。

 * もし、ImeSetCompositonString のlpRead引数が利用可能であれば：
   IMEは、変換文字列を、読みの文字列lpReadから作成できる。
   IMEはそのとき、新しい変換文字列と読み文字列lpReadのために、
   属性と文節を作成する。IMEは、WM_IME_COMPOSITION メッセージを
   GCS_COMPかGCS_COMPREADのいずれかをつけて、生成する。
   ときおり、IMEは、変換を自動的にファイナライズしうる。
   IMEはそのとき、WM_IME_COMPOSITIONメッセージを、GCS_COMPxxxの代わりに
   GCS_RESULTかGCS_RESULTREAD をつけて生成できる。

 * もし、ImeSetCompositonStringの引数lpCompが利用可能であれば：
   IMEは、変換属性と文節情報を変換文字列（lpCompに含まれる）から、
   作成すべきだ。IMEはそのとき、WM_IME_COMPOSITIONメッセージを
   GCS_COMPをつけて生成する。もしIMEがSCS_CAP_MAKEREADの能力が
   あれば、IMEは、新しい読みの文字列も同時に作成すべきだ。
   IMEはそのとき、WM_IME_COMPOSITION メッセージを
   GCS_COMPかGCS_COMPREADのいずれかをつけて生成する。
   ときおり、IMEは、変換をファイナライズしうる。
   IMEはそのとき、WM_IME_COMPOSITIONメッセージを、
   GCS_COMPxxxの代わりにGCS_RESULT かGCS_RESULTREAD のいずれかをつけて
  生成できる。
 * lpRead とlpComp の両方利用可能であれば：
   IMEは、変換文字列と対応する読みの文字列を作成すべきだ。
   この場合、IME は、lpComp とlpRead に完全に従う必要はない。
   もし、IMEが、アプリによって指定されたlpReadとlpCompの
   関係がわからないときは、変換文字列を修正すべきだ。
   IMEはそのとき、新しい変換文字列と読みの文字列lpReadの
   両方に属性と文節情報を作成できる。
   IMEはそのとき、WM_IME_COMPOSITION メッセージを
   GCS_COMPかGCS_COMPREADのいずれかをつけて生成する。
   ときおり、IMEは、変換をファイナライズしうる。
   IMEはそのとき、WM_IME_COMPOSITION メッセージを、
   GCS_COMPxxxの代わりに、GCS_RESULT かGCS_RESULTREAD のいずれかをつけて
   生成できる。

==SCS_CHANGEATTR

SCS_CHANGEATTRは、属性情報にのみ影響する。
IMEは、変換文字列、変換文字列の文節情報、変換文字列の読み、
または、読み文字列の文節情報を更新すべきではない。
IMEは最初に、新しい属性を受け入れ可能かどうかをチェックする必要がある。
そしてそれは、hIMCのCOMPOSITIONSTRING 構造体の中の新しい属性をセットする。
最後に、IME は、WM_IME_COMPOSITION メッセージを生成する。
必要ならば、IMEは、候補情報を更新し、候補メッセージWM_IME_NOTIFYを
サブメッセージIMN_OPENCANDIDATE、CHANGECANDIDATE、または
IMN_CLOSECANDIDATE をつけて、生成できる。

